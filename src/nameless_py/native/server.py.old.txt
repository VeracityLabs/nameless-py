import asyncio
import importlib.util
import logging
import os
import sys
from contextlib import asynccontextmanager
from dataclasses import dataclass
from typing import Optional, Union, Protocol, Any, TypeVar

import click
import uvicorn
from fastapi import FastAPI, HTTPException, Request, APIRouter, Depends
from pydantic import BaseModel, Field
from rich.logging import RichHandler

from config import SERVER_DATA_DIR
from see3_python.library.main import Issuer
from see3_python.util.common import (
    get_server_data,
    get_server_data_silent,
    save_server_data,
)
from see3_python.util.http_result import (
    HttpResult,
    http_ok,
    is_http_ok,
    get_http_value,
)
from see3_python.util.script_conditionals import (
    process_conditionally,
    process_unconditionally,
    ChecksType,
    ProcessType,
)

T = TypeVar("T")

# Constants
LOGGING_FORMAT = "%(message)s"
LOGGING_DATEFMT = "[%X]"

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format=LOGGING_FORMAT,
    datefmt=LOGGING_DATEFMT,
    handlers=[RichHandler()],
)

logger = logging.getLogger("server")

router = APIRouter()


class RevokeUserRequest(BaseModel):
    user_id: str = Field(..., description="The ID of the user to revoke")
    auxiliary: Any = Field({}, description="Additional data for the revocation process")


class CredentialRequest(BaseModel):
    request: str = Field(..., description="The credential request data")
    auxiliary: Any = Field({}, description="Additional data for the credential request")


class CredentialUpdateRequest(BaseModel):
    request: str = Field(..., description="The credential update request data")


class RecoverUserIdRequest(BaseModel):
    request: str = Field(..., description="The user ID recovery request data")
    auxiliary: Any = Field(
        {}, description="Additional data for the user ID recovery request"
    )


@dataclass
class ServerConfig(Protocol):
    """Protocol defining the server configuration interface."""

    issuer: Issuer
    issue_checks: ChecksType
    revoke_checks: ChecksType
    open_checks: ChecksType


@dataclass
class ServerConfigImpl:
    """Implementation of the ServerConfig protocol."""

    issuer: Issuer
    issue_checks: ChecksType
    revoke_checks: ChecksType
    open_checks: ChecksType

    def update_issuer(self, new_issuer_bytes: bytes):
        """Update the issuer using its from_bytes method."""
        self.issuer._update_server_data(new_issuer_bytes)


def get_server_config(request: Request) -> ServerConfig:
    """Dependency to retrieve the server configuration from the request state."""
    return request.app.state.server_config


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Lifespan context manager for the FastAPI application."""
    try:
        if app.state.silent_mode:
            initial_server_data, encrypted_name, salt, password = (
                get_server_data_silent(
                    app.state.server_data_dir,
                    app.state.password,
                    app.state.max_messages,
                )
            )
        else:
            initial_server_data, encrypted_name, salt, password = get_server_data(
                app.state.server_data_dir
            )

        issuer = Issuer.from_bytes(initial_server_data)
        app.state.server_config = ServerConfigImpl(
            issuer=issuer,
            issue_checks=app.state.issue_checks,
            revoke_checks=app.state.revoke_checks,
            open_checks=app.state.open_checks,
        )
        logger.info("Authentication Successful. Server is Running.")
        yield
        final_server_data = app.state.server_config.issuer.to_bytes()
        if initial_server_data != final_server_data:
            save_server_data(
                app.state.server_data_dir,
                encrypted_name,
                final_server_data,
                salt,
                password,
            )
    except asyncio.CancelledError:
        logger.info("Server Shutting Down.")
    except Exception as e:
        logger.error(f"Failed during app lifespan: {e}")
        raise RuntimeError(f"Failed during app lifespan: {e}")
    finally:
        app.state.server_config = None


@router.get("/get_public_key")
async def api_get_public_key(config: ServerConfig = Depends(get_server_config)):
    """
    Retrieve the server's public key.

    Args:
        config (ServerConfig): The server configuration.

    Returns:
        dict: A dictionary containing the public key as a hexadecimal string.

    Raises:
        HTTPException: If the issuer is not initialized.
    """
    logger.info("Received Request For Public Key.")
    if config.issuer is None:
        logger.error("Issuer not initialized")
        raise HTTPException(status_code=503, detail="Issuer not initialized")
    result: HttpResult = await handle_request(config.issuer.get_server_public_key, None)
    if is_http_ok(result):
        return {"status": result.ok_value["status"], "body": result.ok_value["body"]}
    else:
        return {
            "status": result.err_value["status"],
            "detail": result.err_value["detail"],
        }


@router.get("/get_current_epoch")
async def api_get_current_epoch(
    config: ServerConfig = Depends(get_server_config),
):
    """
    Retrieve the current accumulator from the server.

    Args:
        config (ServerConfig): The server configuration.

    Returns:
        dict: A dictionary containing the current accumulator as a hexadecimal string.

    Raises:
        HTTPException: If the issuer is not initialized.
    """
    logger.info("Received Request For Current Accumulator.")
    if config.issuer is None:
        logger.error("Issuer not initialized")
        raise HTTPException(status_code=503, detail="Issuer not initialized")
    result = await handle_request(config.issuer._get_current_accumulator, None)
    if is_http_ok(result):
        return {"status": result.ok_value["status"], "body": result.ok_value["body"]}
    else:
        return {
            "status": result.err_value["status"],
            "detail": result.err_value["detail"],
        }


class AccumulatorQuery(BaseModel):
    start: int
    end: int


@router.get("/fetch_accumulators")
async def fetch_accumulators(
    accumulator_query: AccumulatorQuery,
    config: ServerConfig = Depends(get_server_config),
):
    """ """
    db = config.issuer._get_accumulator_registry()
    if accumulator_query.start < 0 or accumulator_query.end > len(db):
        raise ValueError("Invalid Range")
    entries = db[accumulator_query.start : accumulator_query.end]
    return [entry.to_json() for entry in entries]


@router.post("/issue_requested_credential")
async def api_issue_requested_credential(
    cred_request: CredentialRequest, config: ServerConfig = Depends(get_server_config)
):
    """
    Issue a requested credential to a user.

    Args:
        cred_request (CredentialRequest): The credential request data.
        config (ServerConfig): The server configuration.


    Returns:
        dict: A dictionary containing the issued credential as a hexadecimal string.

    Raises:
        HTTPException: If the issuer or issue checks are not initialized, or if an error occurs during processing.
    """
    logger.info("Received Request To Issue Requested Credential.")
    if config.issuer is None:
        logger.error("Issuer not initialized")
        raise HTTPException(status_code=503, detail="Issuer not initialized")
    if config.issue_checks is None:
        logger.error("Issue checks not initialized. Try Again Later.")
        raise HTTPException(
            status_code=500, detail="Issue checks not initialized. Try Again Later."
        )
    result: HttpResult = await handle_request_conditionally(
        config.issuer.issue_requested_credential,
        config.issue_checks,
        bytes.fromhex(cred_request.request),
        cred_request.auxiliary,
    )
    if is_http_ok(result):
        return {"status": result.ok_value["status"], "body": result.ok_value["body"]}
    else:
        return {
            "status": result.err_value["status"],
            "detail": result.err_value["detail"],
        }


@router.post("/update_requested_credential")
async def api_update_requested_credential(
    cred_update_request: CredentialUpdateRequest,
    config: ServerConfig = Depends(get_server_config),
):
    """
    Update a requested credential for a user.

    Args:
        cred_update_request (CredentialUpdateRequest): The credential update request data.
        config (ServerConfig): The server configuration.

    Returns:
        dict: A dictionary containing the updated credential as a hexadecimal string.

    Raises:
        HTTPException: If the issuer is not initialized, or if an error occurs during processing.
    """
    logger.info("Received Request To Update Requested Credential.")
    if config.issuer is None:
        logger.error("Issuer not initialized")
        raise HTTPException(status_code=503, detail="Issuer not initialized")
    result: HttpResult = await handle_request(
        config.issuer.update_credential,
        bytes.fromhex(cred_update_request.request),
    )
    if is_http_ok(result):
        return get_http_value(result), result.ok_value["status"]
    else:
        return get_http_value(result), result.err_value["status"]


@router.post("/revoke_user")
async def api_revoke_user(
    revoke_request: RevokeUserRequest, config: ServerConfig = Depends(get_server_config)
):
    """
    Revoke a user's credentials.

    Args:
        revoke_request (RevokeUserRequest): The user revocation request data.
        config (ServerConfig): The server configuration.

    Returns:
        dict: A dictionary containing the revocation result as a hexadecimal string.

    Raises:
        HTTPException: If the issuer or revoke checks are not initialized, or if an error occurs during processing.
    """
    async with asyncio.Lock():
        logger.info(
            f"Received Request To Revoke User With ID: {revoke_request.user_id}"
        )
        if config.issuer is None:
            logger.error("Issuer not initialized")
            raise HTTPException(status_code=503, detail="Issuer not initialized")
        if config.revoke_checks is None:
            logger.error("Revoke checks not initialized. Try Again Later.")
            raise HTTPException(
                status_code=500,
                detail="Revoke checks not initialized. Try Again Later.",
            )
        result: HttpResult = await handle_request_conditionally(
            config.issuer.revoke_user,
            config.revoke_checks,
            bytes.fromhex(revoke_request.user_id),
            revoke_request.auxiliary,
        )
        if is_http_ok(result):
            return get_http_value(result), result.ok_value["status"]
        else:
            return get_http_value(result), result.err_value["status"]


@router.post("/recover_user_id")
async def api_recover_user_id(
    recover_request: RecoverUserIdRequest,
    config: ServerConfig = Depends(get_server_config),
):
    """
    Recover a user's ID from a proof.

    Args:
        recover_request (RecoverUserIdRequest): The user ID recovery request data.
        config (ServerConfig): The server configuration.

    Returns:
        dict: A dictionary containing the recovered user ID as a hexadecimal string.

    Raises:
        HTTPException: If the issuer or open checks are not initialized, or if an error occurs during processing.
    """
    logger.info("Received Request To Recover User ID.")
    if config.issuer is None:
        logger.error("Issuer not initialized")
        raise HTTPException(status_code=503, detail="Issuer not initialized")
    result = await handle_request_conditionally(
        config.issuer.recover_user_id_from_proof,
        config.open_checks,
        bytes.fromhex(recover_request.request),
        recover_request.auxiliary,
    )
    if is_http_ok(result):
        return get_http_value(result), result.ok_value["status"]
    else:
        return get_http_value(result), result.err_value["status"]


async def handle_request(func, request: Union[bytes, None]) -> HttpResult:
    try:
        result: bytes = process_unconditionally(func, request)
        return http_ok(result.hex())
    except ValueError as e:
        logger.error(f"Validation error in handle_request: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error in handle_request: {e}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")


async def handle_request_conditionally(
    process: ProcessType[T],
    condition: ChecksType[T],
    request: Union[bytes, None],
    auxiliary: Union[object, None],
) -> HttpResult:
    """
    Handle a request by processing it conditionally.

    Args:
        process (Callable): The function to process the request.
        condition (Callable): The condition function to check before processing.
        request (Union[bytes, None]): The request data.
        auxiliary (Union[object, None]): Additional data for processing.

    Returns:
        dict: A dictionary containing the result as a hexadecimal string.

    Raises:
        HTTPException: If an error occurs during processing or validation.
    """
    try:
        return process_conditionally(process, condition, request, auxiliary)
    except ValueError as e:
        logger.error(f"Value error in handle_request_conditionally: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except HTTPException as e:
        logger.error(f"HTTP error in handle_request_conditionally: {e.detail}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in handle_request_conditionally: {e}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")


@click.command()
@click.option("--script_path", required=True, help="Path To Conditional Script")
@click.option("--port", default=8000, help="Port to run the server on")
@click.option("--log", type=click.Path(), help="Path to log file")
@click.option("--server_dir", type=click.Path(), help="Path to server data directory")
@click.option("--silent", is_flag=True, help="Run in silent mode")
@click.option("--password", help="Password for the server (required in silent mode)")
@click.option(
    "--max_messages",
    type=int,
    help="Maximum number of messages (optional in silent mode)",
)
def main(
    script_path: str,
    port: int,
    log: Optional[str],
    server_dir: Optional[str],
    silent: bool,
    password: Optional[str],
    max_messages: Optional[int],
) -> None:
    if log:
        file_handler = logging.FileHandler(log)
        file_handler.setLevel(logging.INFO)
        file_handler.setFormatter(
            logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
        )
        logger.addHandler(file_handler)

    try:
        spec = importlib.util.spec_from_file_location("module.name", script_path)
        if spec is None:
            raise ImportError(f"Failed to import script from {script_path}")
        module = importlib.util.module_from_spec(spec)
        sys.modules["module.name"] = module
        if spec.loader is None:
            raise ImportError(f"Failed to load script from {script_path}")
        spec.loader.exec_module(module)

        if (
            not hasattr(module, "issue")
            or not hasattr(module, "revoke")
            or not hasattr(module, "open")
        ):
            raise AttributeError(
                "The provided script must have 'issue', 'revoke', and 'open' functions."
            )

        if not callable(module.issue):
            raise TypeError("The 'issue' function must be callable.")
        if not callable(module.revoke):
            raise TypeError("The 'revoke' function must be callable.")
        if not callable(module.open):
            raise TypeError("The 'open' function must be callable.")

        issue_checks = module.issue
        revoke_checks = module.revoke
        open_checks = module.open

        app = FastAPI(lifespan=lifespan)
        app.state.issue_checks = issue_checks
        app.state.revoke_checks = revoke_checks
        app.state.open_checks = open_checks
        app.include_router(router)

        if hasattr(module, "additional_routes"):
            additional_routes = module.additional_routes
            app.include_router(additional_routes)

        if server_dir:
            server_dir = os.path.abspath(server_dir)
            if not os.path.isdir(server_dir):
                raise ValueError(
                    f"The specified server directory does not exist: {server_dir}"
                )

        app.state.server_data_dir = server_dir or SERVER_DATA_DIR
        app.state.silent_mode = silent
        app.state.max_messages = max_messages

        if silent:
            if not password:
                logger.error("Password is required in silent mode")
                sys.exit(1)

            try:
                app.state.password = password
                logger.info("Silent authentication successful.")
            except Exception as e:
                logger.error(f"Silent authentication failed: {e}")
                sys.exit(1)

        logger.info(f"Server is initialized at port {port}.")
        uvicorn.run(app, host="0.0.0.0", port=port, log_level="warning")
    except ImportError as e:
        logger.error(e)
        sys.exit(1)
    except AttributeError as e:
        logger.error(e)
        sys.exit(1)
    except TypeError as e:
        logger.error(e)
        sys.exit(1)
    except Exception as e:
        logger.error(f"Failed to start server: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
